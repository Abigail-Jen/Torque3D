//-----------------------------------------------------------------------------
/// Copyright (c) 2013-2017 BitBox, Ltd.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//-----------------------------------------------------------------------------

#pragma once

#ifndef _CORE_UTIL_COMMAND_H_
#define _CORE_UTIL_COMMAND_H_
#include "console/console.h"
#include "core/util/command_impl.h"

#include <future>

/**
 * @brief Command is a generic implementation of "all or nothing" call-chains
 * @details Command is a sequence of "tasks" and if one of them fails, all
 * previous ones will be rolled back in a reversed order.
 *
 * Each task (represented via @see GenericTask, created via helper functions
 * like @see Command::Task::MainThread()) is an object that consists of two
 * callable objects: one called "execution" functor that does the "useful" work
 * that caller wants to perform, the other called "rollback" functor that
 * rolls back the effects of the execution functor if needed.
 *
 * The first difference between the classic Command pattern and this is the
 * ability to pass results (return values) of a task to the next task in a
 * statically checked type-safe way that does not require much from the user.
 *
 * The second difference is the option to perform different tasks of a single
 * Command in different threads (@see Command::Task::WorkerThread(),
 * @see Command::Task::DbThread()). This allows to construct complex call-chains
 * that jump between threads with simple means of implementing rollback logic.
 *
 * Note that it does not make sense to use Command if all tasks are in the same
 * thread - other patterns like scope_guard allow to achieve the same goals
 * via much simpler means.
 *
 *
 * Due to generic nature of Command, the signature of each execution functor
 * is restricted. Execution functor must generate return values via @see TaskResult()
 * helper function which allows to separately specify three things: task status
 * (perfomed successfully or failed), input for the execution functor of the
 * next task, input for the rollback functor of the current task. Return statement
 * will look like
 * 		return TaskResult(true, ForNextTask(10, "someStr"), ForRollback(std::make_unique<int>());
 *
 * Boolean status is mandatory, but the rest of the TaskResult() may be ommited
 * if you do not needed it
 *
 *
 * Usage example:
 *
 * auto mainThreadTask = Command::Task::MainThread(
 * 		[]() // "execution" functor
 * 		{
 * 			const int value = 42;
 * 			std::cout << "main thread says " << value << std::endl;
 * 			return TaskResult(true, ForNextTask(value), ForRollback(10));
 * 		},
 * 		[](int inputValue) // "rollback" functor
 * 		{
 * 			std::cout << "main thread is rolling back and says " << inputValue << std::endl;
 * 		}
 * 	);
 * auto workerThreadTask = Command::Task::WorkerThread(
 * 		[](int inputValue)
 * 		{
 * 			std::cout << "worker thread says " << inputValue << std::endl;
 *
 *			// If a task does not require additional data to perform rollback
 *			// or next task does not require any data generated by previous one,
 *			// you can skip either one or both of `ForNextTask` and `ForRollback`
 *			// output parameters
 * 			return TaskResult(true, ForNextTask(std::string("dolphins")));
 * 		},
 * 		[]() // Rollback functor does not have input paramters since
 * 		{    // execution functor did not specify any
 *
 * 			std::cout << "worker thread is rolling back" << std::endl;
 * 		}
 * 	);
 * auto dbThreadTask = Command::Task::DbThread(
 * 		[](const std::string& inputStr)
 * 		{
 * 			std::cout << "db thread says " << inputStr << std::endl;
 * 			return TaskResult(false);
 * 		},
 * 		[](){}
 * 	);
 *
 * auto cmd = Command::Make(mainThreadTask, workerThreadTask, dbThreadTask);
 * Command::Execute(std::move(cmd));
 *
 * The code above will print:
 * 		main thread says 42
 * 		worker thread says 42
 * 		db thread says dolphins
 * 		worker thread is rolling back
 * 		main thread is rolling back and says 10
 */
namespace Command
{

/**
 * @brief Command object factory function
 *
 * @param  A sequence of GenericTask objects which should be generated via
 * helper functions like @see Command::Task::MainThread()
 * @return Command object that should be moved into @see Command::Execute()
 */
template <typename... Tasks>
Details::Cmd<Tasks...> Make(Tasks&&...);

/**
 * @brief Launches Command object execution, will consume the Command object
 *
 * @param  Command object generated by @see Command::Make()
 * @return std::future object which value will be set when the related Command
 * object has fully finished execution or was fully rolled back
 */
template <typename... Tasks>
std::future<Result> Execute(Details::Cmd<Tasks...>);

} // namespace Command

/**
 * @brief Helper function that should be used together with @see TaskResult()
 * in a return statement of execution functor.
 * @details Data passed into this function will be input for the execution functor
 * of next task in Command
 */
template <typename... T>
auto ForNextTask(T&&... args)
{
	return std::make_tuple(Command::Details::Task::ForNextTaskTupleTag(), std::forward<T>(args)...);
}

/**
 * @brief Helper function that should be used together with @see TaskResult()
 * in a return statement of execution functor.
 * @details Data passed into this function will be input for the rollback functor
 * of the current task if rollback of the Command happens
 */
template <typename... T>
auto ForRollback(T&&... args)
{
	return std::make_tuple(Command::Details::Task::ForRollbackTupleTag(), std::forward<T>(args)...);
}

/**
 * @brief Helper function that should be used in a return of execution functor
 *
 * @param success Indicates whether execution functor succeeded (in this case
 * next task will be performed) or failed (in this case rollback will be initiated)
 * @param forNext Input for execution functor of the next task, should be created
 * via @see ForNextTask()
 * @param forRollback Input for rollback functor of the current task, should be created
 * via @see ForRollback()
 */
template <
	template <typename...> class T1, typename... Types1,
	template <typename...> class T2, typename... Types2
	>
auto TaskResult(bool success, T1<Types1...>&& forNext, T2<Types2...>&& forRollback)
{
	using Next = std::remove_reference_t<decltype(forNext)>;
	using Rollback = std::remove_reference_t<decltype(forRollback)>;
	static_assert(StdX::Traits::IsTuple<Next>::value && StdX::Traits::IsTuple<Rollback>::value,
		"TaskResult() expects tuples as input");
	static_assert(
		std::is_same<Command::Details::Task::ForNextTaskTupleTag, std::tuple_element_t<0, Next>>::value
		&& std::is_same<Command::Details::Task::ForRollbackTupleTag, std::tuple_element_t<0, Rollback>>::value,
		"TaskResult() expects tuples generated by ForNextTask() and ForRollback() helper functions");
	static_assert(
		StdX::Traits::AllOf<std::is_default_constructible, std::remove_reference_t<Types1>...>::value
		&& StdX::Traits::AllOf<std::is_default_constructible, std::remove_reference_t<Types2>...>::value,
		"Command does not support non-default-constructible types in return statement");

	return std::make_tuple(success, std::move(forNext), std::move(forRollback));
}

// NOTE: For some reason MSVC2015 can't properly perform overload resolution
// between TaskResult() calls if two-argument version is used if
// Command::Details::Task::ForNextTaskTuple<T...> or ForRollbackTuple<T...>
// types are used. Beucause of this manually expanded tuple types are used
template <typename... T>
auto TaskResult(bool success, std::tuple<Command::Details::Task::ForNextTaskTupleTag, T...>&& forNext)
{
	return TaskResult(success, std::move(forNext), Command::Details::Task::ForRollbackTuple<>());
}

template <typename... T>
auto TaskResult(bool success, std::tuple<Command::Details::Task::ForRollbackTupleTag, T...>&& forRollback)
{
	return TaskResult(success, Command::Details::Task::ForNextTaskTuple<>(), std::move(forRollback));
}

inline auto TaskResult(bool success)
{
	return TaskResult(success,
		Command::Details::Task::ForNextTaskTuple<>(),
		Command::Details::Task::ForRollbackTuple<>());
}

template <typename... T>
auto TaskResult(T&&...)
{
	static_assert(false,
		"Invalid parameters passed to TaskResult(), call structure should look like "
		"TaskResult(true, ForNextTask(...), ForRollback(...))");
	return TaskResult(false);
}

namespace Command
{

namespace Task
{

struct PushToMainThread
{
	template <typename... Tasks>
	void moveToTargetThread(Details::Cmd<Tasks...> cmd) const
	{
		auto execute = [](Details::Cmd<Tasks...> cmd)
		{
			Details::Cmd<Tasks...>::ContinueExecution(std::move(cmd));
		};
		Async::Force::CallInMainThread(execute, std::move(cmd));
	}

	bool isInTargetThread() const
	{
		return Con::isMainThread();
	}
};

template <typename ExecuteFunc, typename RollbackFunc>
auto MainThread(ExecuteFunc&& execute, RollbackFunc&& rollback)
{
	return Details::Task::GenericTask<ExecuteFunc, RollbackFunc, PushToMainThread>(
		std::forward<ExecuteFunc>(execute),
		std::forward<RollbackFunc>(rollback),
		PushToMainThread());
}

template <typename ExecuteFunc>
auto MainThread(ExecuteFunc&& execute)
{
	return MainThread(std::forward<ExecuteFunc>(execute), [](){});
}

} // namespace Task

} // namespace Command

#endif // _CORE_UTIL_COMMAND_H_
